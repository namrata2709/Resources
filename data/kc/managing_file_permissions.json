{
  "title": "Managing File Permissions",
  "topic": "Linux File Permissions and Security",
  "questions": [
    {
      "id": 1,
      "question": "Which command allows the user to set permissions for files and directories?",
      "options": [
        {
          "id": "A",
          "text": "chgrp",
          "isCorrect": false,
          "explanation": {
            "summary": "The chgrp (change group) command changes only the group ownership of files and directories, not the permission settings.",
            "why": "chgrp is specifically designed to modify group ownership, which is different from permissions. While group ownership affects who can access a file based on group membership, permissions (read, write, execute) determine what actions users can perform. To change permissions, you need chmod.",
            "examples": [
              "'chgrp developers file.txt' changes the group owner to developers",
              "'chgrp -R staff /project' recursively changes group for directory"
            ],
            "learnMore": [
              {
                "title": "Linuxize - chgrp Command Guide",
                "url": "https://linuxize.com/post/chgrp-command-in-linux/"
              }
            ]
          }
        },
        {
          "id": "B",
          "text": "chmod",
          "isCorrect": true,
          "explanation": {
            "summary": "The chmod (change mode) command is the standard Linux tool for modifying file and directory permissions. It allows you to control who can read, write, or execute files by setting permissions for the owner, group, and others using either symbolic notation (letters) or absolute mode (numbers).",
            "keyPoints": [
              "Primary command for changing file and directory permissions",
              "Supports two modes: symbolic (u+rwx) and numeric/absolute (755)",
              "Controls three permission types: read (r/4), write (w/2), execute (x/1)",
              "Sets permissions for three user classes: owner (u), group (g), others (o)",
              "Can add (+), remove (-), or set (=) permissions",
              "Requires file ownership or root privileges to modify permissions",
              "Supports recursive changes with -R option for directories"
            ],
            "examples": [
              "'chmod 755 script.sh' sets rwxr-xr-x (owner full, others read-execute)",
              "'chmod u+x file.sh' adds execute permission for owner",
              "'chmod g-w document.txt' removes write permission from group",
              "'chmod a=r file.txt' sets read-only for all users",
              "'chmod -R 750 /project' recursively sets permissions on directory"
            ],
            "additionalInfo": "The chmod command is fundamental to Linux security because it implements the permissions model that controls file access. Every file has three sets of permissions (owner, group, others) and three permission types (read, write, execute). In numeric mode, each digit represents one user class, calculated by adding permission values: read=4, write=2, execute=1. So chmod 755 means owner gets 7 (4+2+1=rwx), group gets 5 (4+1=r-x), and others get 5 (4+1=r-x). In symbolic mode, you use letters and operators: 'chmod u+x file' adds execute for user, 'chmod go-w file' removes write from group and others. The command works on both files and directories, but execute permission means different things: for files it means you can run them, for directories it means you can cd into them and access their contents.",
            "learnMore": [
              {
                "title": "Linuxize - chmod Command in Linux",
                "url": "https://linuxize.com/post/chmod-command-in-linux/"
              },
              {
                "title": "DigitalOcean - How to Set Permissions in Linux",
                "url": "https://www.digitalocean.com/community/tutorials/how-to-set-permissions-linux"
              },
              {
                "title": "GeeksforGeeks - chmod Command with Examples",
                "url": "https://www.geeksforgeeks.org/linux-unix/chmod-command-linux/"
              },
              {
                "title": "How-To Geek - How to Use chmod Command",
                "url": "https://www.howtogeek.com/437958/how-to-use-the-chmod-command-on-linux/"
              }
            ]
          }
        },
        {
          "id": "C",
          "text": "umask",
          "isCorrect": false,
          "explanation": {
            "summary": "The umask command sets default permissions for newly created files and directories, but it doesn't change permissions on existing files.",
            "why": "umask defines a permission mask that determines what permissions are automatically removed from new files when they're created. It doesn't modify permissions on existing files or directories. For example, 'umask 022' means new files get 644 (rw-r--r--) permissions. To change permissions on existing files, use chmod.",
            "examples": [
              "'umask 022' sets default to remove write for group and others on new files",
              "'umask' displays current umask value",
              "New files created after setting umask inherit these defaults"
            ],
            "learnMore": [
              {
                "title": "Baeldung - Understanding umask",
                "url": "https://www.baeldung.com/linux/umask-file-permissions"
              }
            ]
          }
        },
        {
          "id": "D",
          "text": "su",
          "isCorrect": false,
          "explanation": {
            "summary": "The su (switch user) command changes your user identity, typically to gain root privileges, but doesn't directly modify file permissions.",
            "why": "su allows you to become another user (usually root) to perform administrative tasks. While you might use su to gain privileges before running chmod, su itself doesn't change file permissions. It's a privilege escalation command, not a permission modification command.",
            "examples": [
              "'su' switches to root user",
              "'su - alice' switches to alice's account",
              "After using su, you can then run chmod to change permissions"
            ],
            "learnMore": [
              {
                "title": "Red Hat - Difference Between sudo and su",
                "url": "https://www.redhat.com/en/blog/difference-between-sudo-su"
              }
            ]
          }
        }
      ]
    },
    {
      "id": 2,
      "question": "Which of the following is an example of Absolute mode?",
      "options": [
        {
          "id": "A",
          "text": "chmod",
          "isCorrect": false,
          "explanation": {
            "summary": "'chmod' by itself is just the command name, not an example of absolute or symbolic mode. It needs to be followed by either numeric values or symbolic notation plus a filename.",
            "why": "The chmod command requires arguments to function. Absolute mode requires numeric values (like 755), while symbolic mode uses letters and operators (like u+rwx). Simply typing 'chmod' without any mode specification or filename is incomplete and will result in an error.",
            "learnMore": [
              {
                "title": "Red Hat - Introduction to chmod",
                "url": "https://www.redhat.com/en/blog/introduction-chmod"
              }
            ]
          }
        },
        {
          "id": "B",
          "text": "chmod a=r filename",
          "isCorrect": false,
          "explanation": {
            "summary": "This is an example of symbolic mode, not absolute mode. It uses letters (a for all users, r for read) and an operator (=) to set permissions.",
            "why": "Symbolic mode uses letter-based notation with user classes (u, g, o, a), operators (+, -, =), and permission letters (r, w, x). The command 'chmod a=r filename' translates to 'set read-only permission for all users'. Absolute mode, in contrast, uses three numeric digits like 444 for the same result.",
            "examples": [
              "'chmod a=r file.txt' - symbolic mode setting read-only for all",
              "Equivalent absolute mode: 'chmod 444 file.txt'"
            ],
            "learnMore": [
              {
                "title": "Opensource.com - Introduction to chmod",
                "url": "https://opensource.com/article/19/8/linux-chmod-command"
              }
            ]
          }
        },
        {
          "id": "C",
          "text": "chmod filename",
          "isCorrect": false,
          "explanation": {
            "summary": "This command is incomplete and will produce an error. The chmod command requires a mode (either numeric or symbolic) before the filename.",
            "why": "The proper syntax for chmod is 'chmod [mode] filename' where mode can be numeric (755) or symbolic (u+rwx). Without specifying what permissions to set, chmod doesn't know what changes to make and will fail with a syntax error.",
            "learnMore": [
              {
                "title": "Medium - chmod Linux Command Introduction",
                "url": "https://medium.com/@hdeodato/chmod-linux-command-fa90f217586f"
              }
            ]
          }
        },
        {
          "id": "D",
          "text": "chmod 757 filename",
          "isCorrect": true,
          "explanation": {
            "summary": "This is a perfect example of absolute mode (also called numeric or octal mode). It uses three digits where each digit represents permissions for owner, group, and others respectively. The numeric values are calculated by adding read (4), write (2), and execute (1) permissions.",
            "keyPoints": [
              "Uses three-digit numeric notation (octal values)",
              "Each digit represents one user class: owner, group, others",
              "Each digit is sum of permission values: read=4, write=2, execute=1",
              "First digit (7) = owner permissions (rwx = 4+2+1)",
              "Second digit (5) = group permissions (r-x = 4+0+1)",
              "Third digit (7) = others permissions (rwx = 4+2+1)",
              "Sets all permissions at once, replacing any existing permissions"
            ],
            "examples": [
              "'chmod 755 script.sh' - owner: rwx (7), group: r-x (5), others: r-x (5)",
              "'chmod 644 document.txt' - owner: rw- (6), group: r-- (4), others: r-- (4)",
              "'chmod 700 private.sh' - owner: rwx (7), group: --- (0), others: --- (0)",
              "'chmod 777 shared.txt' - everyone: rwx (7) - full permissions for all",
              "'chmod 400 secret.key' - owner: r-- (4), no permissions for group or others"
            ],
            "additionalInfo": "Absolute mode is called 'absolute' because it sets the exact permissions you specify, completely replacing any existing permissions. This differs from symbolic mode which can add or remove permissions incrementally. In the example 'chmod 757 filename', the breakdown is: 7 (first digit) = 4+2+1 giving the owner read+write+execute, 5 (second digit) = 4+1 giving the group read+execute, and 7 (third digit) = 4+2+1 giving others read+write+execute. This is a permissive setting that gives full control to the owner and others, but restricts the group from writing. Common patterns include 755 for executable scripts (owner can modify, others can run), 644 for documents (owner can edit, others can read), and 600 for private files (only owner has any access). System administrators often prefer absolute mode for setting exact, known permission states.",
            "learnMore": [
              {
                "title": "Ricmedia - Linux File Permissions Tutorial",
                "url": "https://www.ricmedia.com/tutorials/linux-file-permissions-tutorial"
              },
              {
                "title": "Computer Hope - chmod Command",
                "url": "https://www.computerhope.com/unix/uchmod.htm"
              },
              {
                "title": "DigitalOcean - How to Set Permissions",
                "url": "https://www.digitalocean.com/community/tutorials/how-to-set-permissions-linux"
              },
              {
                "title": "GeeksforGeeks - chmod Command Examples",
                "url": "https://www.geeksforgeeks.org/linux-unix/chmod-command-linux/"
              }
            ]
          }
        }
      ]
    },
    {
      "id": 3,
      "question": "Which command displays the permissions for files and directories?",
      "options": [
        {
          "id": "A",
          "text": "ls -r",
          "isCorrect": false,
          "explanation": {
            "summary": "The -r option lists files in reverse order, not permissions. This option reverses the sorting order but doesn't change what information is displayed.",
            "why": "ls -r simply reverses the sort order of the file list (Z to A instead of A to Z, or newest to oldest instead of oldest to newest). It doesn't show file permissions. To see permissions, you need the -l (long format) option.",
            "examples": [
              "'ls -r' lists files in reverse alphabetical order",
              "'ls -rt' lists files in reverse time order (oldest first)"
            ],
            "learnMore": [
              {
                "title": "GeeksforGeeks - ls Command in Linux",
                "url": "https://www.geeksforgeeks.org/ls-command-in-linux/"
              }
            ]
          }
        },
        {
          "id": "B",
          "text": "ls -l",
          "isCorrect": true,
          "explanation": {
            "summary": "The ls -l command displays files and directories in long format, which includes comprehensive information about each item including permissions, number of links, owner, group, size, modification time, and name. The permission string appears as the first column in the output.",
            "keyPoints": [
              "Displays long listing format with detailed file information",
              "Shows 10-character permission string (e.g., -rw-r--r--)",
              "First character indicates file type (- for file, d for directory, l for link)",
              "Next 9 characters show permissions in three groups of three (owner, group, others)",
              "Also displays owner name, group name, file size, and timestamp",
              "Essential command for auditing file access rights",
              "Can be combined with other options like -a (all files) or -h (human-readable sizes)"
            ],
            "examples": [
              "'ls -l file.txt' shows: -rw-r--r-- 1 user group 1234 Dec 22 10:30 file.txt",
              "'ls -l /etc' displays permissions for all files in /etc directory",
              "'ls -la' shows all files including hidden ones with permissions",
              "'ls -lh' displays permissions with human-readable file sizes (KB, MB)",
              "Permission string breakdown: drwxr-xr-x means directory with rwx for owner, r-x for group and others"
            ],
            "additionalInfo": "The ls -l command output format is standard across Unix-like systems and provides critical security information at a glance. The permission string consists of 10 characters: the first indicates the file type (- for regular file, d for directory, l for symbolic link, c for character device, b for block device), followed by three groups of three characters representing read, write, and execute permissions for owner, group, and others respectively. For example, '-rw-r--r--' means it's a regular file where the owner can read and write, while group members and others can only read. The owner and group columns show who owns the file and which group has group permissions. System administrators routinely use 'ls -l' to verify proper permission settings, identify security issues, and ensure files are accessible to the right users while being protected from unauthorized access.",
            "learnMore": [
              {
                "title": "Linuxize - How to List Files Using ls Command",
                "url": "https://linuxize.com/post/how-to-list-files-in-linux-using-the-ls-command/"
              },
              {
                "title": "GeeksforGeeks - ls Command with Examples",
                "url": "https://www.geeksforgeeks.org/ls-command-in-linux/"
              },
              {
                "title": "TecMint - 15 ls Command Examples",
                "url": "https://www.tecmint.com/15-basic-ls-command-examples-in-linux/"
              },
              {
                "title": "Atlantic.Net - ls Command Options Guide",
                "url": "https://www.atlantic.net/dedicated-server-hosting/how-to-use-linux-ls-command-with-options/"
              }
            ]
          }
        },
        {
          "id": "C",
          "text": "ls -a",
          "isCorrect": false,
          "explanation": {
            "summary": "The -a option shows all files including hidden files (those starting with a dot), but it doesn't display permissions unless combined with -l.",
            "why": "ls -a lists all files in the directory, including hidden files like .bashrc and .ssh, which are normally not shown. However, by default it uses the short format that only shows filenames without permission details. To see permissions, you need 'ls -la' which combines both options.",
            "examples": [
              "'ls -a' shows all files including .hidden files",
              "'ls -la' shows all files with permissions in long format"
            ],
            "learnMore": [
              {
                "title": "Linuxize - ls Command Guide",
                "url": "https://linuxize.com/post/how-to-list-files-in-linux-using-the-ls-command/"
              }
            ]
          }
        },
        {
          "id": "D",
          "text": "ls",
          "isCorrect": false,
          "explanation": {
            "summary": "The ls command without options displays only filenames in the current directory. It doesn't show permissions, ownership, size, or other file metadata.",
            "why": "Basic 'ls' provides a simple list of visible files and directories. It's useful for quick directory browsing but doesn't show the detailed information needed for permission auditing. To see permissions, use 'ls -l' for long format.",
            "examples": [
              "'ls' shows: file1.txt file2.txt directory1",
              "'ls -l' shows: -rw-r--r-- 1 user group 1234 Dec 22 file1.txt"
            ],
            "learnMore": [
              {
                "title": "GeeksforGeeks - ls Command Examples",
                "url": "https://www.geeksforgeeks.org/ls-command-in-linux/"
              }
            ]
          }
        }
      ]
    },
    {
      "id": 4,
      "question": "Which command is used to change the user or group of a file or directory?",
      "options": [
        {
          "id": "A",
          "text": "chown",
          "isCorrect": true,
          "explanation": {
            "summary": "The chown (change owner) command is the primary tool for changing file and directory ownership in Linux. It can modify the user owner, the group owner, or both simultaneously. Ownership is fundamental to Linux security because it determines which user account has ultimate control over a file and which group members can access it based on group permissions.",
            "keyPoints": [
              "Changes user owner, group owner, or both for files and directories",
              "Syntax: chown user:group filename or chown user filename",
              "Requires root or sudo privileges to execute",
              "Can change ownership recursively for directories with -R option",
              "Accepts numeric UIDs and GIDs as well as names",
              "Separate command chgrp exists but chown can do the same job",
              "Ownership determines who has ultimate control over file permissions"
            ],
            "examples": [
              "'sudo chown alice file.txt' changes owner to alice",
              "'sudo chown alice:developers file.txt' changes owner to alice and group to developers",
              "'sudo chown :staff file.txt' changes only group to staff",
              "'sudo chown -R www-data:www-data /var/www' recursively changes ownership for web directory",
              "'sudo chown 1000:1000 file.txt' uses numeric user and group IDs"
            ],
            "additionalInfo": "The chown command is essential for managing file security and access control in multi-user Linux environments. When you specify 'chown user:group file', the colon separates the user from the group. You can change just the user ('chown user file'), just the group ('chown :group file'), or both. The command requires superuser privileges because allowing regular users to give away file ownership would create security risks. Common use cases include: transferring project files between developers, setting proper ownership after extracting archives, configuring web server directories (often owned by www-data), and fixing permission issues after moving files between systems. The -R (recursive) option is particularly useful for changing ownership of entire directory trees, but use it carefully as it affects all subdirectories and files within.",
            "learnMore": [
              {
                "title": "Linuxize - chown Command Tutorial",
                "url": "https://linuxize.com/post/linux-chown-command/"
              },
              {
                "title": "PhoenixNAP - chown Command with Examples",
                "url": "https://phoenixnap.com/kb/linux-chown-command-with-examples"
              },
              {
                "title": "GeeksforGeeks - chown Command in Linux",
                "url": "https://www.geeksforgeeks.org/linux-unix/chown-command-in-linux-with-examples/"
              },
              {
                "title": "Hostinger - How to Use chown Command",
                "url": "https://www.hostinger.com/tutorials/linux-chown-command"
              }
            ]
          }
        },
        {
          "id": "B",
          "text": "chmod",
          "isCorrect": false,
          "explanation": {
            "summary": "The chmod command changes file permissions (read, write, execute), not ownership. Ownership and permissions are two different aspects of file security.",
            "why": "chmod modifies what actions can be performed on a file (read, write, execute), but it doesn't change who owns the file or which group is associated with it. To change the user or group owner, you need chown or chgrp.",
            "examples": [
              "'chmod 755 file.sh' changes permissions, not ownership",
              "Use 'chown alice file.txt' to change ownership instead"
            ],
            "learnMore": [
              {
                "title": "IOFlood - chown vs chmod",
                "url": "https://ioflood.com/blog/chown-linux-command/"
              }
            ]
          }
        },
        {
          "id": "C",
          "text": "umask",
          "isCorrect": false,
          "explanation": {
            "summary": "The umask command sets default permission masks for newly created files, but doesn't change ownership of existing files or directories.",
            "why": "umask determines what permissions are automatically applied when new files are created. It has no effect on ownership - new files are always owned by the user who creates them and that user's primary group. To change ownership, use chown.",
            "learnMore": [
              {
                "title": "Computer Hope - chown Command",
                "url": "https://www.computerhope.com/unix/uchown.htm"
              }
            ]
          }
        },
        {
          "id": "D",
          "text": "su",
          "isCorrect": false,
          "explanation": {
            "summary": "The su command switches your user identity but doesn't change file ownership. It's a privilege escalation tool, not an ownership management command.",
            "why": "su changes which user you're operating as (usually switching to root for administrative tasks). While you might use su before running chown, su itself doesn't modify file ownership. After using su to become root, you would then run chown to change file ownership.",
            "examples": [
              "'su' switches to root user",
              "Then run 'chown alice file.txt' to change ownership"
            ],
            "learnMore": [
              {
                "title": "Atlantic.Net - How to Use chown Command",
                "url": "https://www.atlantic.net/dedicated-server-hosting/how-to-use-chown-change-ownership-command-in-linux/"
              }
            ]
          }
        }
      ]
    },
    {
      "id": 5,
      "question": "Which statement reflects the principle of least privilege?",
      "options": [
        {
          "id": "A",
          "text": "Give the least number of users the least amount of file access first, and grant more permissions only when the user has a need.",
          "isCorrect": true,
          "explanation": {
            "summary": "This statement perfectly captures the principle of least privilege (PoLP), a fundamental security concept that requires granting users only the minimum access rights necessary to perform their legitimate job functions. By starting with minimal access and expanding only when justified, organizations reduce their attack surface, limit potential damage from breaches, and maintain better security accountability.",
            "keyPoints": [
              "Users receive minimum permissions required for their specific job role",
              "Access is granted on a need-to-know and need-to-do basis",
              "Permissions are expanded only when business justification exists",
              "Reduces attack surface by limiting what each user can access or modify",
              "Minimizes damage from compromised accounts or insider threats",
              "Requires regular review and adjustment of permissions",
              "Fundamental principle in zero-trust security architectures"
            ],
            "examples": [
              "Developer gets read-only access to production logs, write access only to development environment",
              "Database administrator can manage databases but cannot access application source code",
              "Web content editor can modify website content but cannot change server configurations",
              "Backup user account has permission only to read files for backup, cannot delete or modify",
              "Financial analyst accesses financial data but not HR personnel records"
            ],
            "additionalInfo": "The principle of least privilege is one of the oldest and most important security concepts in computing, dating back to the earliest multi-user systems. In Linux, implementing PoLP involves multiple layers: using regular user accounts instead of root for daily work, granting sudo access only for specific commands rather than blanket superuser rights, setting file permissions restrictively (like 640 instead of 666), organizing users into specific groups with defined access rights, and using SELinux or AppArmor for additional access controls. The principle doesn't just apply to human users - it extends to service accounts, applications, and processes. A web server should run as a limited user (like www-data) rather than root, and should only have access to the specific directories it needs to serve content. Regular audits are essential because user roles change over time, and permissions that were once needed may no longer be appropriate. The goal is to find the balance between security and productivity - give users enough access to do their jobs efficiently, but no more than necessary.",
            "learnMore": [
              {
                "title": "BeyondTrust - What Is Least Privilege",
                "url": "https://www.beyondtrust.com/blog/entry/what-is-least-privilege"
              },
              {
                "title": "LabEx - Implementing Least Privilege for Linux Users",
                "url": "https://labex.io/tutorials/linux-how-to-implement-least-privilege-for-linux-user-accounts-411671"
              },
              {
                "title": "WafaiCloud - Implementing Least Privilege Access",
                "url": "https://wafaicloud.com/blog/implementing-least-privilege-access-in-linux-environments/"
              },
              {
                "title": "Wikipedia - Principle of Least Privilege",
                "url": "https://en.wikipedia.org/wiki/Principle_of_least_privilege"
              },
              {
                "title": "StrongDM - Principle of Least Privilege Explained",
                "url": "https://www.strongdm.com/blog/principle-of-least-privilege"
              }
            ]
          }
        },
        {
          "id": "B",
          "text": "Give a small number of users the most amount of access to all files.",
          "isCorrect": false,
          "explanation": {
            "summary": "This approach directly violates the principle of least privilege by granting excessive access to users who may not need it, creating unnecessary security risks.",
            "why": "Giving maximum access to even a small group creates multiple security problems: if any of those accounts is compromised, the attacker gains extensive system access; there's no accountability since multiple users have the same access level; accidental mistakes can affect any part of the system; and it violates audit requirements that demand need-based access. The principle of least privilege requires that access be limited to what's specifically needed, not maximized for convenience.",
            "examples": [
              "If 5 admins all have full root access, you can't determine who made configuration changes",
              "One compromised admin account with full access can destroy the entire system"
            ],
            "learnMore": [
              {
                "title": "TheServerSide - Principle of Least Privilege Examples",
                "url": "https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/Principle-of-Least-Privilege-Examples"
              }
            ]
          }
        },
        {
          "id": "C",
          "text": "Give no access to any files for a large number of users, and give only the network engineer access to all files.",
          "isCorrect": false,
          "explanation": {
            "summary": "This approach is impractical and still violates least privilege principles by concentrating all access in a single role that likely doesn't need access to everything.",
            "why": "While restricting access to most users seems secure, giving one person (network engineer) access to all files creates a single point of failure and violates least privilege because network engineers don't need access to application code, financial data, HR records, and every other file on the system. The principle requires that each user, including network engineers, receives only the access needed for their specific job functions.",
            "examples": [
              "Network engineer needs access to network configs, not payroll databases",
              "If the network engineer's account is compromised, the attacker gets everything"
            ],
            "learnMore": [
              {
                "title": "Daily.dev - Linux User Groups and Permissions",
                "url": "https://daily.dev/blog/linux-user-groups-and-permissions-guide"
              }
            ]
          }
        },
        {
          "id": "D",
          "text": "Give access to all groups, and each group can decide which individual has access to each file.",
          "isCorrect": false,
          "explanation": {
            "summary": "Delegating access control decisions to groups without oversight creates security chaos and violates centralized access management principles.",
            "why": "This approach removes centralized security control and creates inconsistent access policies across the organization. Groups may grant access too liberally without understanding security implications, there's no audit trail of who approved access decisions, different groups may have conflicting policies, and there's no enforcement of the principle of least privilege. Proper implementation requires centralized policies with groups used as an implementation mechanism, not as decision-makers.",
            "examples": [
              "Marketing group grants access to financial data without security review",
              "Different groups create overlapping and conflicting access rules"
            ],
            "learnMore": [
              {
                "title": "Oracle - Follow the Principle of Least Privilege",
                "url": "https://docs.oracle.com/en/operating-systems/oracle-linux/9/security/security-FollowthePrincipleofLeastPrivilege.html"
              }
            ]
          }
        }
      ]
    }
  ]
}