<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Container Orchestration & Kubernetes - Overview</title>
    <link rel="stylesheet" href="../../../css/notes-template.css">
</head>
<body>
    <button id="themeToggle" class="theme-toggle">
        <span class="theme-icon"></span>
    </button>

    <div class="note-container">
        <div class="note-header">
            <h1>Container Orchestration & Kubernetes</h1>
            <p class="note-date">üìÖ December 23, 2025</p>
        </div>

        <div class="note-content">
            <h2>üìã Table of Contents</h2>
            <ol>
                <li><a href="#docker-fundamentals">Docker Fundamentals</a></li>
                <li><a href="#docker-components">Docker Components & Architecture</a></li>
                <li><a href="#docker-images">Docker Images & Registries</a></li>
                <li><a href="#docker-compose">Docker Compose & Multi-Container Management</a></li>
                <li><a href="#orchestration-need">Why Container Orchestration?</a></li>
                <li><a href="#kubernetes-architecture">Kubernetes Architecture</a></li>
                <li><a href="#kubernetes-components">Kubernetes Components</a></li>
                <li><a href="#aws-ecs">AWS ECS (Elastic Container Service)</a></li>
                <li><a href="#aws-eks">AWS EKS (Elastic Kubernetes Service)</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
            </ol>

            <h2 id="docker-fundamentals">üê≥ Docker Fundamentals</h2>
            
            <h3>What is Docker?</h3>
            <p>Docker is a containerization platform that packages applications and their dependencies into lightweight, portable containers. Unlike virtual machines, containers share the host OS kernel, making them more efficient.</p>

            <h3>Container vs Virtual Machine</h3>
            <table>
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>Container</th>
                        <th>Virtual Machine</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>OS</td>
                        <td>Shares host OS kernel</td>
                        <td>Separate guest OS for each VM</td>
                    </tr>
                    <tr>
                        <td>Size</td>
                        <td>Lightweight (MBs)</td>
                        <td>Heavy (GBs)</td>
                    </tr>
                    <tr>
                        <td>Startup Time</td>
                        <td>Seconds</td>
                        <td>Minutes</td>
                    </tr>
                    <tr>
                        <td>Resource Allocation</td>
                        <td>Dynamic (uses what's needed)</td>
                        <td>Pre-allocated (fixed memory/CPU)</td>
                    </tr>
                    <tr>
                        <td>Isolation</td>
                        <td>Process-level</td>
                        <td>Hardware-level</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="docker-components">‚öôÔ∏è Docker Components & Architecture</h2>

            <h3>Docker Installation Components</h3>
            <p>When you install Docker, you receive two main components:</p>

            <h4>1. Docker CLI (Command Line Interface)</h4>
            <p>The user interface that allows interaction with Docker through commands.</p>

            <h4>2. Docker Daemon (Service)</h4>
            <p>The background service that manages Docker containers, images, networks, and volumes.</p>

            <h3>Practical Implementation</h3>

            <h4>Method 1: AWS CLI - Installing Docker on Ubuntu EC2</h4>
            <pre><code># Update system packages
sudo apt-get update

# Install Docker
sudo apt-get install -y docker.io

# Enable Docker service to start on boot
sudo systemctl enable docker

# Start Docker service
sudo systemctl start docker

# Verify Docker installation
docker --version

# Check Docker service status
sudo systemctl status docker</code></pre>

            <h4>Method 2: AWS Console - Setting Up EC2 for Docker</h4>
            <ol>
                <li>Open <strong>AWS Management Console</strong> and navigate to <strong>EC2</strong></li>
                <li>Click <strong>Launch Instance</strong></li>
                <li>Select <strong>Ubuntu 22.04 LTS</strong> AMI</li>
                <li>Choose instance type (t2.micro for testing)</li>
                <li>Configure security group:
                    <ul>
                        <li>Allow SSH (port 22)</li>
                        <li>Allow HTTP (port 80) if running web apps</li>
                        <li>Allow custom ports for your applications</li>
                    </ul>
                </li>
                <li>Launch instance and connect via SSH</li>
                <li>Run Docker installation commands from Method 1</li>
            </ol>

            <h3>User Permissions Configuration</h3>

            <div class="highlight-box">
                <p>‚ö†Ô∏è <strong>Important:</strong> By default, only the root user can run Docker commands. Non-root users must be added to the docker group.</p>
            </div>

            <h4>Adding User to Docker Group</h4>

            <h5>Method 1: CLI Commands</h5>
            <pre><code># Add current user to docker group
sudo usermod -aG docker $USER

# For Ubuntu EC2 instances
sudo usermod -aG docker ubuntu

# Activate group changes (Option 1 - Run this command)
newgrp docker

# Or (Option 2 - Reconnect to session)
exit
# Then reconnect via SSH

# Verify user can run Docker without sudo
docker ps</code></pre>

            <h5>Method 2: Manual Configuration</h5>
            <ol>
                <li>Check if docker group exists: <code>cat /etc/group | grep docker</code></li>
                <li>If not exists, create group: <code>sudo groupadd docker</code></li>
                <li>Add user to group: <code>sudo usermod -aG docker username</code></li>
                <li>Verify group membership: <code>groups username</code></li>
                <li>Restart Docker service: <code>sudo systemctl restart docker</code></li>
            </ol>

            <div class="success-box">
                <p>‚úÖ <strong>Troubleshooting Checklist:</strong></p>
                <ul>
                    <li>Confirm Docker daemon is running: <code>sudo systemctl status docker</code></li>
                    <li>Verify user is in docker group: <code>groups</code></li>
                    <li>If issues persist, log out and log back in</li>
                </ul>
            </div>

            <h2 id="docker-images">üì¶ Docker Images & Registries</h2>

            <h3>Understanding Docker Images</h3>
            <p>A Docker image is a <strong>read-only template</strong> containing:</p>
            <ul>
                <li>Base operating system (lightweight)</li>
                <li>Application code</li>
                <li>Dependencies and libraries</li>
                <li>Configuration files</li>
                <li>Environment variables</li>
            </ul>

            <h3>Dockerfile Structure</h3>
            <p>A Dockerfile contains instructions to build a Docker image:</p>

            <pre><code># Use a base image
FROM python:3.9-slim

# Set working directory inside container
WORKDIR /app

# Copy application files
COPY requirements.txt .
COPY app.py .

# Install dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Expose application port
EXPOSE 5000

# Define startup command
CMD ["python", "app.py"]</code></pre>

            <h3>Building and Running Containers</h3>

            <h4>Method 1: Using Docker CLI</h4>
            <pre><code># Build image from Dockerfile
docker build -t my-python-app:1.0 .

# List all images
docker images

# Run container from image
docker run -d -p 8080:5000 --name my-app my-python-app:1.0

# Explanation of flags:
# -d: Run in detached mode (background)
# -p 8080:5000: Map host port 8080 to container port 5000
# --name: Assign name to container
# my-python-app:1.0: Image name and tag

# View running containers
docker ps

# View all containers (including stopped)
docker ps -a

# Stop container
docker stop my-app

# Start stopped container
docker start my-app

# Remove container
docker rm my-app

# Remove image
docker rmi my-python-app:1.0</code></pre>

            <h3>Docker Image Registries</h3>

            <h4>Public Registry: Docker Hub</h4>
            <p>Docker Hub is the default public registry for Docker images.</p>

            <h5>Using Docker Hub (CLI)</h5>
            <pre><code># Login to Docker Hub
docker login

# Tag image for Docker Hub
docker tag my-python-app:1.0 username/my-python-app:1.0

# Push image to Docker Hub
docker push username/my-python-app:1.0

# Pull image from Docker Hub
docker pull username/my-python-app:1.0

# Pull official images
docker pull nginx:latest
docker pull ubuntu:22.04
docker pull python:3.9-slim</code></pre>

            <h5>Using Docker Hub (Console)</h5>
            <ol>
                <li>Visit <strong>hub.docker.com</strong></li>
                <li>Create an account or sign in</li>
                <li>Click <strong>Create Repository</strong></li>
                <li>Choose <strong>Public</strong> or <strong>Private</strong></li>
                <li>Name your repository</li>
                <li>Use CLI commands above to push images</li>
            </ol>

            <h4>Private Registry: AWS ECR (Elastic Container Registry)</h4>

            <h5>Method 1: AWS CLI</h5>
            <pre><code># Create ECR repository
aws ecr create-repository \
    --repository-name my-app \
    --region us-east-1

# Get login credentials
aws ecr get-login-password --region us-east-1 | \
    docker login --username AWS \
    --password-stdin ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com

# Tag image for ECR
docker tag my-python-app:1.0 \
    ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/my-app:1.0

# Push to ECR
docker push ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/my-app:1.0

# Pull from ECR
docker pull ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/my-app:1.0</code></pre>

            <h5>Method 2: AWS Console</h5>
            <ol>
                <li>Open <strong>AWS Console</strong> ‚Üí <strong>ECR</strong></li>
                <li>Click <strong>Create repository</strong></li>
                <li>Enter <strong>Repository name</strong></li>
                <li>Choose <strong>Private</strong> visibility</li>
                <li>Configure:
                    <ul>
                        <li><strong>Image scanning:</strong> Enable for security</li>
                        <li><strong>KMS encryption:</strong> Optional for enhanced security</li>
                    </ul>
                </li>
                <li>Click <strong>Create repository</strong></li>
                <li>Click on repository name to view <strong>Push commands</strong></li>
                <li>Follow the displayed CLI commands to push images</li>
            </ol>

            <h3>Comparison: Public vs Private Registries</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Docker Hub (Public)</th>
                        <th>AWS ECR (Private)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Access</td>
                        <td>Anyone can pull public images</td>
                        <td>Requires AWS authentication</td>
                    </tr>
                    <tr>
                        <td>Security</td>
                        <td>Basic (username/password)</td>
                        <td>IAM roles and policies</td>
                    </tr>
                    <tr>
                        <td>Cost</td>
                        <td>Free (with limits)</td>
                        <td>Pay for storage and transfer</td>
                    </tr>
                    <tr>
                        <td>Integration</td>
                        <td>Works with any Docker host</td>
                        <td>Seamless AWS service integration</td>
                    </tr>
                    <tr>
                        <td>Use Case</td>
                        <td>Open source, public projects</td>
                        <td>Enterprise, proprietary applications</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="docker-compose">üîó Docker Compose & Multi-Container Management</h2>

            <h3>What is Docker Compose?</h3>
            <p>Docker Compose is a tool for defining and running multi-container Docker applications using a YAML configuration file.</p>

            <h3>When to Use Docker Compose</h3>
            <ul>
                <li>Applications with multiple services (frontend, backend, database)</li>
                <li>Microservices architecture</li>
                <li>Development environments requiring multiple containers</li>
                <li>Need to manage container dependencies</li>
            </ul>

            <h3>Docker Compose File Structure</h3>
            <pre><code>version: '3.8'

services:
  # Frontend service
  frontend:
    image: my-frontend:1.0
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - app-network

  # Backend service
  backend:
    image: my-backend:1.0
    ports:
      - "5000:5000"
    environment:
      - DATABASE_URL=mongodb://database:27017
    depends_on:
      - database
    networks:
      - app-network

  # Database service
  database:
    image: mongo:latest
    volumes:
      - mongo-data:/data/db
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  mongo-data:</code></pre>

            <h3>Docker Compose Commands</h3>

            <h4>Method 1: Using Docker Compose CLI</h4>
            <pre><code># Start all services defined in docker-compose.yml
docker-compose up -d

# View running services
docker-compose ps

# View logs from all services
docker-compose logs

# View logs from specific service
docker-compose logs frontend

# Stop all services
docker-compose stop

# Stop and remove containers, networks
docker-compose down

# Stop and remove containers, networks, volumes
docker-compose down -v

# Restart specific service
docker-compose restart backend

# Scale a service (create multiple instances)
docker-compose up -d --scale backend=3

# Build images before starting
docker-compose up --build</code></pre>

            <h3>Docker Networking</h3>

            <h4>Network Types</h4>
            <table>
                <thead>
                    <tr>
                        <th>Network Type</th>
                        <th>Description</th>
                        <th>Use Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Bridge</td>
                        <td>Default network for containers on same host</td>
                        <td>Local development, isolated applications</td>
                    </tr>
                    <tr>
                        <td>Host</td>
                        <td>Container uses host's network directly</td>
                        <td>High-performance applications, no isolation needed</td>
                    </tr>
                    <tr>
                        <td>Overlay</td>
                        <td>Connects containers across multiple hosts</td>
                        <td>Swarm mode, distributed applications</td>
                    </tr>
                    <tr>
                        <td>None</td>
                        <td>No network connectivity</td>
                        <td>Security testing, isolated operations</td>
                    </tr>
                </tbody>
            </table>

            <h4>Network Management Commands</h4>
            <pre><code># Create custom network
docker network create my-network

# List networks
docker network ls

# Inspect network
docker network inspect my-network

# Connect container to network
docker network connect my-network container-name

# Disconnect container from network
docker network disconnect my-network container-name

# Run container on specific network
docker run -d --network my-network --name app nginx</code></pre>

            <h3>Docker Volumes (Data Persistence)</h3>

            <h4>Why Use Volumes?</h4>
            <p>Containers are ephemeral - when deleted, all data inside is lost. Volumes provide persistent storage.</p>

            <h4>Volume Types</h4>
            <table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Description</th>
                        <th>Command Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Named Volume</td>
                        <td>Docker-managed storage</td>
                        <td><code>docker run -v my-volume:/data nginx</code></td>
                    </tr>
                    <tr>
                        <td>Bind Mount</td>
                        <td>Mount host directory</td>
                        <td><code>docker run -v /host/path:/container/path nginx</code></td>
                    </tr>
                    <tr>
                        <td>tmpfs Mount</td>
                        <td>Temporary memory storage</td>
                        <td><code>docker run --tmpfs /tmp nginx</code></td>
                    </tr>
                </tbody>
            </table>

            <h4>Volume Commands</h4>
            <pre><code># Create volume
docker volume create my-data

# List volumes
docker volume ls

# Inspect volume
docker volume inspect my-data

# Remove unused volumes
docker volume prune

# Run container with volume
docker run -d -v my-data:/app/data --name myapp nginx

# Bind mount (development)
docker run -d -v $(pwd):/app --name dev-app node:latest</code></pre>

            <h2 id="orchestration-need">üé≠ Why Container Orchestration?</h2>

            <h3>Limitations of Plain Docker</h3>
            <p>While Docker effectively runs containers, it lacks critical features for production environments:</p>

            <div class="error-box">
                <p>‚ùå <strong>Docker Cannot Provide:</strong></p>
                <ul>
                    <li><strong>Auto-scaling:</strong> Automatically increase/decrease container count based on load</li>
                    <li><strong>Load balancing:</strong> Distribute traffic across multiple containers</li>
                    <li><strong>Self-healing:</strong> Automatically restart failed containers</li>
                    <li><strong>Rolling updates:</strong> Update applications without downtime</li>
                    <li><strong>Rollback capability:</strong> Revert to previous version if deployment fails</li>
                    <li><strong>Service discovery:</strong> Containers finding and communicating with each other</li>
                    <li><strong>Health monitoring:</strong> Continuous health checks and automated responses</li>
                </ul>
            </div>

            <h3>Real-World Production Requirements</h3>
            <table>
                <thead>
                    <tr>
                        <th>Requirement</th>
                        <th>Scenario</th>
                        <th>Docker Alone</th>
                        <th>With Orchestration</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>High Availability</td>
                        <td>Server crashes</td>
                        <td>Manual restart needed</td>
                        <td>Automatic recovery on different host</td>
                    </tr>
                    <tr>
                        <td>Traffic Surge</td>
                        <td>Sudden user increase</td>
                        <td>Manual scaling required</td>
                        <td>Auto-scales to handle load</td>
                    </tr>
                    <tr>
                        <td>Container Failure</td>
                        <td>Application crashes</td>
                        <td>Downtime until manual fix</td>
                        <td>Automatic restart/replacement</td>
                    </tr>
                    <tr>
                        <td>Updates</td>
                        <td>New version deployment</td>
                        <td>Requires downtime</td>
                        <td>Zero-downtime rolling updates</td>
                    </tr>
                    <tr>
                        <td>Resource Management</td>
                        <td>15-20 containers</td>
                        <td>Complex manual management</td>
                        <td>Automated scheduling and placement</td>
                    </tr>
                </tbody>
            </table>

            <h3>What is Container Orchestration?</h3>
            <p><strong>Container orchestration</strong> is the automated management of containerized applications in production environments, handling:</p>
            <ul>
                <li>Deployment and scheduling of containers</li>
                <li>Scaling up and down based on demand</li>
                <li>Load balancing across containers</li>
                <li>Health monitoring and self-healing</li>
                <li>Rolling updates and rollbacks</li>
                <li>Service discovery and networking</li>
                <li>Resource allocation and optimization</li>
            </ul>

            <h3>Container Orchestration Tools</h3>
            <table>
                <thead>
                    <tr>
                        <th>Tool</th>
                        <th>Description</th>
                        <th>Best For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Docker Swarm</td>
                        <td>Docker's native orchestration</td>
                        <td>Simple setups, Docker-only environments</td>
                    </tr>
                    <tr>
                        <td>Kubernetes (K8s)</td>
                        <td>Industry-standard, open-source</td>
                        <td>Production environments, cloud-agnostic</td>
                    </tr>
                    <tr>
                        <td>K3s</td>
                        <td>Lightweight Kubernetes</td>
                        <td>IoT, edge computing, resource-constrained</td>
                    </tr>
                    <tr>
                        <td>AWS ECS</td>
                        <td>AWS-native container service</td>
                        <td>AWS-specific deployments</td>
                    </tr>
                    <tr>
                        <td>AWS EKS</td>
                        <td>Managed Kubernetes on AWS</td>
                        <td>Kubernetes on AWS with less management</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="kubernetes-architecture">üéØ Kubernetes Architecture</h2>

            <h3>What is Kubernetes?</h3>
            <p>Kubernetes (K8s) is an open-source container orchestration platform that automates deployment, scaling, and management of containerized applications.</p>

            <div class="info-box">
                <p>üí° <strong>Key Facts:</strong></p>
                <ul>
                    <li><strong>Name origin:</strong> K8s = K + 8 characters + s (ubernete)</li>
                    <li><strong>Type:</strong> Open-source, cloud-agnostic</li>
                    <li><strong>Created by:</strong> Google (now managed by CNCF)</li>
                    <li><strong>Architecture:</strong> Cluster-based with master-worker model</li>
                </ul>
            </div>

            <h3>Kubernetes Cluster Components</h3>
            <p>A Kubernetes cluster consists of two main parts:</p>

            <h4>1. Control Plane (Master Node)</h4>
            <p>The "brain" of the cluster that makes decisions about the cluster's state and responds to events.</p>

            <h4>2. Worker Nodes</h4>
            <p>The "hands" that execute the actual work - running containerized applications.</p>

            <table>
                <thead>
                    <tr>
                        <th>Component</th>
                        <th>Location</th>
                        <th>Role</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Control Plane</td>
                        <td>Master Node</td>
                        <td>Makes decisions, manages cluster state</td>
                    </tr>
                    <tr>
                        <td>Worker Nodes</td>
                        <td>Multiple machines</td>
                        <td>Run application containers (Pods)</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="kubernetes-components">‚öôÔ∏è Kubernetes Components Explained</h2>

            <h3>Control Plane Components</h3>

            <h4>1. API Server</h4>
            <p><strong>Role:</strong> The front door of Kubernetes - all communication goes through it.</p>
            <ul>
                <li>Single entry point for all cluster operations</li>
                <li>Validates and processes REST API requests</li>
                <li>Authenticates and authorizes users</li>
                <li>Forwards requests to appropriate components</li>
            </ul>

            <h4>2. etcd</h4>
            <p><strong>Role:</strong> The cluster's memory - stores all cluster data.</p>
            <ul>
                <li>Distributed key-value store</li>
                <li>Stores cluster state, configuration, and secrets</li>
                <li>Source of truth for cluster information</li>
                <li>Highly available and consistent</li>
            </ul>

            <h4>3. Scheduler</h4>
            <p><strong>Role:</strong> The decision-maker - decides where Pods should run.</p>
            <ul>
                <li>Watches for newly created Pods with no assigned node</li>
                <li>Evaluates resource requirements (CPU, memory)</li>
                <li>Considers constraints and policies</li>
                <li>Assigns Pods to optimal worker nodes</li>
            </ul>

            <h4>4. Controller Manager</h4>
            <p><strong>Role:</strong> The supervisor - ensures desired state matches actual state.</p>
            <p>Contains multiple controllers:</p>
            <ul>
                <li><strong>Node Controller:</strong> Monitors node health</li>
                <li><strong>Replication Controller:</strong> Maintains correct number of Pods</li>
                <li><strong>Endpoints Controller:</strong> Manages service endpoints</li>
                <li><strong>Service Account Controller:</strong> Creates default accounts</li>
            </ul>

            <h4>5. Cloud Controller Manager</h4>
            <p><strong>Role:</strong> Cloud provider interface - integrates with cloud services.</p>
            <ul>
                <li>Manages cloud-specific resources (load balancers, storage)</li>
                <li>Node lifecycle management in cloud</li>
                <li>Route management</li>
            </ul>

            <h3>Worker Node Components</h3>

            <h4>1. Kubelet</h4>
            <p><strong>Role:</strong> The node agent - ensures containers are running.</p>
            <ul>
                <li>Runs on every worker node</li>
                <li>Communicates with API server</li>
                <li>Manages container lifecycle</li>
                <li>Reports node and Pod status</li>
            </ul>

            <h4>2. Container Runtime</h4>
            <p><strong>Role:</strong> The engine - actually runs containers.</p>
            <p>Supported runtimes:</p>
            <ul>
                <li><strong>Containerd:</strong> Industry standard (recommended)</li>
                <li><strong>CRI-O:</strong> Lightweight, Kubernetes-optimized</li>
                <li><strong>Docker:</strong> (deprecated in K8s 1.24+)</li>
            </ul>

            <h4>3. Kube-proxy</h4>
            <p><strong>Role:</strong> The network manager - handles networking rules.</p>
            <ul>
                <li>Maintains network rules on nodes</li>
                <li>Enables communication between Pods</li>
                <li>Implements Kubernetes Service concept</li>
                <li>Manages load balancing</li>
            </ul>

            <h3>Kubernetes Objects</h3>

            <h4>Pod</h4>
            <p>The <strong>smallest deployable unit</strong> in Kubernetes.</p>
            <ul>
                <li>Can contain one or more containers</li>
                <li>Shares network namespace and storage</li>
                <li>Gets unique IP address</li>
                <li>Ephemeral (can be replaced)</li>
            </ul>

            <h4>Deployment</h4>
            <p>Manages <strong>stateless applications</strong> with desired replica count.</p>
            <ul>
                <li>Ensures specified number of Pods running</li>
                <li>Handles rolling updates</li>
                <li>Enables rollback to previous versions</li>
                <li>Self-healing (restarts failed Pods)</li>
            </ul>

            <h4>Service</h4>
            <p>Provides <strong>stable network endpoint</strong> for accessing Pods.</p>
            <ul>
                <li>Load balances traffic across Pods</li>
                <li>Provides service discovery</li>
                <li>Types: ClusterIP, NodePort, LoadBalancer, ExternalName</li>
            </ul>

            <h3>Interacting with Kubernetes</h3>

            <h4>kubectl CLI Commands</h4>
            <pre><code># Get cluster information
kubectl cluster-info
kubectl get nodes

# Deploy application from YAML
kubectl apply -f deployment.yaml

# View deployments
kubectl get deployments
kubectl get pods
kubectl get services

# Describe resource details
kubectl describe pod pod-name
kubectl describe deployment deployment-name

# View logs
kubectl logs pod-name
kubectl logs -f pod-name  # Follow logs

# Execute commands in Pod
kubectl exec -it pod-name -- /bin/bash

# Scale deployment
kubectl scale deployment/my-app --replicas=5

# Delete resources
kubectl delete pod pod-name
kubectl delete deployment deployment-name
kubectl delete -f deployment.yaml</code></pre>

            <h3>Sample Deployment YAML</h3>
            <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            CPU: "250m"
          limits:
            memory: "128Mi"
            cpu: "500m"</code></pre>

            <h2 id="aws-ecs">‚òÅÔ∏è AWS ECS (Elastic Container Service)</h2>

            <h3>What is AWS ECS?</h3>
            <p>ECS is AWS's <strong>native container orchestration service</strong> that manages Docker containers without needing Kubernetes.</p>

            <div class="info-box">
                <p>üí° <strong>Key Concept:</strong> ECS simplifies container management by removing Kubernetes complexity while providing enterprise-grade orchestration features.</p>
            </div>

            <h3>ECS Core Components</h3>
            <table>
                <thead>
                    <tr>
                        <th>Component</th>
                        <th>Description</th>
                        <th>Purpose</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Cluster</td>
                        <td>Logical grouping of resources</td>
                        <td>Organizes tasks and services</td>
                    </tr>
                    <tr>
                        <td>Task Definition</td>
                        <td>Blueprint for containers</td>
                        <td>Defines image, CPU, memory, ports</td>
                    </tr>
                    <tr>
                        <td>Task</td>
                        <td>Running instance of task definition</td>
                        <td>Actual running containers</td>
                    </tr>
                    <tr>
                        <td>Service</td>
                        <td>Maintains desired task count</td>
                        <td>Ensures availability and load balancing</td>
                    </tr>
                </tbody>
            </table>

            <h3>ECS Launch Types</h3>

            <h4>1. EC2 Launch Type</h4>
            <p>You manage the EC2 instances that run containers.</p>
            <ul>
                <li><strong>More control</strong> over underlying infrastructure</li>
                <li>Choose instance types</li>
                <li>Manage patching and scaling</li>
                <li>Cost-effective for long-running workloads</li>
            </ul>

            <h4>2. Fargate Launch Type (Serverless)</h4>
            <p>AWS manages the infrastructure - you only define containers.</p>
            <ul>
                <li><strong>No server management</strong> required</li>
                <li>Pay only for resources used</li>
                <li>Automatic scaling</li>
                <li>Ideal for variable workloads</li>
            </ul>

            <h3>Creating ECS Cluster and Task</h3>

            <h4>Method 1: AWS CLI</h4>
            <pre><code># Create ECS cluster
aws ecs create-cluster \
    --cluster-name my-app-cluster \
    --region us-east-1

# Register task definition
aws ecs register-task-definition \
    --cli-input-json file://task-definition.json

# Run task
aws ecs run-task \
    --cluster my-app-cluster \
    --task-definition my-app-task:1 \
    --count 2 \
    --launch-type FARGATE \
    --network-configuration "awsvpcConfiguration={subnets=[subnet-12345],securityGroups=[sg-12345]}"

# Create service
aws ecs create-service \
    --cluster my-app-cluster \
    --service-name my-app-service \
    --task-definition my-app-task:1 \
    --desired-count 3 \
    --launch-type FARGATE

# List running tasks
aws ecs list-tasks --cluster my-app-cluster

            # Describe service
aws ecs describe-services \
    --cluster my-app-cluster \
    --services my-app-service</code></pre>

            <h4>Method 2: AWS Console</h4>
            <ol>
                <li>Open <strong>AWS Console</strong> ‚Üí <strong>ECS</strong></li>
                <li>Click <strong>Create Cluster</strong></li>
                <li>Choose cluster template:
                    <ul>
                        <li><strong>Networking only:</strong> For Fargate</li>
                        <li><strong>EC2 Linux + Networking:</strong> For EC2 launch type</li>
                    </ul>
                </li>
                <li>Configure cluster:
                    <ul>
                        <li>Enter <strong>Cluster name</strong></li>
                        <li>For EC2: Choose instance type, number of instances</li>
                        <li>Configure VPC and subnets</li>
                    </ul>
                </li>
                <li>Click <strong>Create</strong></li>
                <li>Create <strong>Task Definition</strong>:
                    <ul>
                        <li>Click <strong>Task Definitions</strong> ‚Üí <strong>Create new Task Definition</strong></li>
                        <li>Choose launch type (Fargate or EC2)</li>
                        <li>Enter task definition name</li>
                        <li>Add container:
                            <ul>
                                <li>Container name</li>
                                <li>Image URI (from ECR or Docker Hub)</li>
                                <li>Memory limits (soft/hard)</li>
                                <li>Port mappings</li>
                            </ul>
                        </li>
                        <li>Configure task size (CPU and memory)</li>
                        <li>Click <strong>Create</strong></li>
                    </ul>
                </li>
                <li>Create <strong>Service</strong>:
                    <ul>
                        <li>Navigate to cluster</li>
                        <li>Click <strong>Services</strong> ‚Üí <strong>Create</strong></li>
                        <li>Select task definition</li>
                        <li>Enter service name</li>
                        <li>Set number of tasks (replicas)</li>
                        <li>Configure load balancer (optional)</li>
                        <li>Set Auto Scaling policies</li>
                        <li>Click <strong>Create Service</strong></li>
                    </ul>
                </li>
            </ol>

            <h3>Sample ECS Task Definition JSON</h3>
            <pre><code>{
  "family": "my-app-task",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "containerDefinitions": [
    {
      "name": "my-app-container",
      "image": "123456789.dkr.ecr.us-east-1.amazonaws.com/my-app:latest",
      "portMappings": [
        {
          "containerPort": 80,
          "protocol": "tcp"
        }
      ],
      "essential": true,
      "environment": [
        {
          "name": "ENV",
          "value": "production"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/my-app",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}</code></pre>

            <h3>ECS vs Kubernetes Comparison</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>ECS</th>
                        <th>Kubernetes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Complexity</td>
                        <td>Simple, AWS-specific</td>
                        <td>Complex, steep learning curve</td>
                    </tr>
                    <tr>
                        <td>Cloud Portability</td>
                        <td>AWS-only</td>
                        <td>Cloud-agnostic</td>
                    </tr>
                    <tr>
                        <td>Management</td>
                        <td>Fully managed by AWS</td>
                        <td>Self-managed or EKS</td>
                    </tr>
                    <tr>
                        <td>Cost</td>
                        <td>No cluster management fees</td>
                        <td>Cluster management overhead</td>
                    </tr>
                    <tr>
                        <td>Integration</td>
                        <td>Seamless AWS services</td>
                        <td>Requires configuration</td>
                    </tr>
                    <tr>
                        <td>Best For</td>
                        <td>AWS-native applications</td>
                        <td>Multi-cloud, complex orchestration</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="aws-eks">üé° AWS EKS (Elastic Kubernetes Service)</h2>

            <h3>What is AWS EKS?</h3>
            <p>EKS is <strong>AWS-managed Kubernetes</strong> that runs the Kubernetes control plane across multiple availability zones for high availability.</p>

            <h3>EKS Architecture</h3>
            <p>EKS provides:</p>
            <ul>
                <li><strong>Managed Control Plane:</strong> AWS manages API server, etcd, scheduler, controllers</li>
                <li><strong>Worker Nodes:</strong> You manage (EC2) or AWS manages (Fargate)</li>
                <li><strong>High Availability:</strong> Control plane runs across 3 AZs</li>
                <li><strong>Integration:</strong> Seamless integration with AWS services</li>
            </ul>

            <h3>EKS Worker Node Options</h3>
            <table>
                <thead>
                    <tr>
                        <th>Option</th>
                        <th>Management</th>
                        <th>Use Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Self-Managed Nodes</td>
                        <td>You create and manage EC2 instances</td>
                        <td>Maximum control, custom configurations</td>
                    </tr>
                    <tr>
                        <td>Managed Node Groups</td>
                        <td>AWS automates node provisioning</td>
                        <td>Simplified management, automatic updates</td>
                    </tr>
                    <tr>
                        <td>Fargate</td>
                        <td>AWS manages all infrastructure</td>
                        <td>Serverless, no node management</td>
                    </tr>
                </tbody>
            </table>

            <h3>Creating EKS Cluster</h3>

            <h4>Method 1: AWS CLI (using eksctl)</h4>
            <pre><code># Install eksctl (EKS CLI tool)
curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
sudo mv /tmp/eksctl /usr/local/bin

# Create EKS cluster with managed node group
eksctl create cluster \
    --name my-eks-cluster \
    --region us-east-1 \
    --nodegroup-name my-nodes \
    --node-type t3.medium \
    --nodes 3 \
    --nodes-min 1 \
    --nodes-max 4 \
    --managed

# Update kubeconfig to connect to cluster
aws eks update-kubeconfig \
    --region us-east-1 \
    --name my-eks-cluster

# Verify connection
kubectl get nodes
kubectl get pods --all-namespaces

# Deploy application
kubectl apply -f deployment.yaml

# Create service
kubectl apply -f service.yaml

# Get services
kubectl get svc

# Delete cluster
eksctl delete cluster --name my-eks-cluster --region us-east-1</code></pre>

            <h4>Method 2: AWS Console</h4>
            <ol>
                <li><strong>Prerequisites:</strong>
                    <ul>
                        <li>Create IAM role for EKS cluster</li>
                        <li>Create VPC with public/private subnets</li>
                    </ul>
                </li>
                <li>Open <strong>AWS Console</strong> ‚Üí <strong>EKS</strong></li>
                <li>Click <strong>Add cluster</strong> ‚Üí <strong>Create</strong></li>
                <li>Configure cluster:
                    <ul>
                        <li>Enter <strong>Cluster name</strong></li>
                        <li>Select <strong>Kubernetes version</strong></li>
                        <li>Choose <strong>Cluster service role</strong></li>
                    </ul>
                </li>
                <li>Configure networking:
                    <ul>
                        <li>Select <strong>VPC</strong></li>
                        <li>Choose <strong>Subnets</strong> (minimum 2 in different AZs)</li>
                        <li>Select <strong>Security groups</strong></li>
                        <li>Choose <strong>Cluster endpoint access</strong> (Public/Private)</li>
                    </ul>
                </li>
                <li>Configure observability (optional):
                    <ul>
                        <li>Enable <strong>Control plane logging</strong></li>
                    </ul>
                </li>
                <li>Click <strong>Create</strong> (takes 10-15 minutes)</li>
                <li><strong>Add Node Group:</strong>
                    <ul>
                        <li>Navigate to cluster ‚Üí <strong>Compute</strong> tab</li>
                        <li>Click <strong>Add node group</strong></li>
                        <li>Enter node group name</li>
                        <li>Choose <strong>Node IAM role</strong></li>
                        <li>Select instance types (e.g., t3.medium)</li>
                        <li>Configure scaling:
                            <ul>
                                <li>Minimum: 1</li>
                                <li>Maximum: 4</li>
                                <li>Desired: 2</li>
                            </ul>
                        </li>
                        <li>Click <strong>Create</strong></li>
                    </ul>
                </li>
                <li><strong>Connect to cluster:</strong>
                    <ul>
                        <li>Install kubectl and AWS CLI</li>
                        <li>Run: <code>aws eks update-kubeconfig --name my-eks-cluster --region us-east-1</code></li>
                        <li>Verify: <code>kubectl get nodes</code></li>
                    </ul>
                </li>
            </ol>

            <h3>EKS vs ECS vs Kubernetes Comparison</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>ECS</th>
                        <th>EKS</th>
                        <th>Self-Managed K8s</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Complexity</td>
                        <td>Low</td>
                        <td>Medium</td>
                        <td>High</td>
                    </tr>
                    <tr>
                        <td>Kubernetes</td>
                        <td>No</td>
                        <td>Yes</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td>Management Overhead</td>
                        <td>Very Low</td>
                        <td>Low (control plane)</td>
                        <td>High (everything)</td>
                    </tr>
                    <tr>
                        <td>Cloud Portability</td>
                        <td>AWS-only</td>
                        <td>Limited (K8s standard)</td>
                        <td>Full portability</td>
                    </tr>
                    <tr>
                        <td>Cost</td>
                        <td>No extra fees</td>
                        <td>$0.10/hour per cluster</td>
                        <td>EC2 costs only</td>
                    </tr>
                    <tr>
                        <td>Learning Curve</td>
                        <td>Gentle</td>
                        <td>Steep</td>
                        <td>Very Steep</td>
                    </tr>
                    <tr>
                        <td>Best For</td>
                        <td>Simple AWS apps</td>
                        <td>K8s + AWS benefits</td>
                        <td>Multi-cloud expertise</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="best-practices">‚úÖ Best Practices</h2>

            <h3>Docker Best Practices</h3>
            <ul>
                <li>‚úÖ Use official base images from Docker Hub</li>
                <li>‚úÖ Keep images small (use alpine or slim variants)</li>
                <li>‚úÖ Use specific image tags (avoid <code>latest</code> in production)</li>
                <li>‚úÖ Minimize layers in Dockerfile</li>
                <li>‚úÖ Use <code>.dockerignore</code> to exclude unnecessary files</li>
                <li>‚úÖ Run containers as non-root user</li>
                <li>‚úÖ Use multi-stage builds for smaller images</li>
                <li>‚úÖ Scan images for vulnerabilities before deployment</li>
            </ul>

            <h3>Container Security</h3>
            <ul>
                <li>üîí Never store secrets in images</li>
                <li>üîí Use environment variables or secret management services</li>
                <li>üîí Regularly update base images and dependencies</li>
                <li>üîí Implement least privilege access</li>
                <li>üîí Enable image scanning in ECR</li>
                <li>üîí Use private registries for proprietary applications</li>
            </ul>

            <h3>Kubernetes Best Practices</h3>
            <ul>
                <li>‚úÖ Define resource requests and limits</li>
                <li>‚úÖ Use namespaces to organize resources</li>
                <li>‚úÖ Implement readiness and liveness probes</li>
                <li>‚úÖ Use ConfigMaps for configuration</li>
                <li>‚úÖ Use Secrets for sensitive data</li>
                <li>‚úÖ Implement RBAC (Role-Based Access Control)</li>
                <li>‚úÖ Use Deployments (not bare Pods)</li>
                <li>‚úÖ Enable Pod autoscaling (HPA)</li>
                <li>‚úÖ Use Service Mesh for complex microservices</li>
            </ul>

            <h3>ECS/EKS Best Practices</h3>
            <ul>
                <li>üí∞ Use Fargate for variable workloads to optimize costs</li>
                <li>üí∞ Use Spot Instances for non-critical workloads</li>
                <li>‚úÖ Enable container insights for monitoring</li>
                <li>‚úÖ Use Application Load Balancer for HTTP/HTTPS traffic</li>
                <li>‚úÖ Implement auto-scaling policies</li>
                <li>‚úÖ Use ECR for private image storage</li>
                <li>‚úÖ Enable logging to CloudWatch</li>
                <li>‚úÖ Tag resources for cost allocation</li>
            </ul>

            <h3>Production Deployment Checklist</h3>
            <table>
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Checkpoint</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Images</td>
                        <td>Stored in private registry (ECR)</td>
                        <td>‚òê</td>
                    </tr>
                    <tr>
                        <td>Security</td>
                        <td>Vulnerability scanning enabled</td>
                        <td>‚òê</td>
                    </tr>
                    <tr>
                        <td>Resources</td>
                        <td>CPU/Memory limits defined</td>
                        <td>‚òê</td>
                    </tr>
                    <tr>
                        <td>Health</td>
                        <td>Health checks configured</td>
                        <td>‚òê</td>
                    </tr>
                    <tr>
                        <td>Scaling</td>
                        <td>Auto-scaling policies set</td>
                        <td>‚òê</td>
                    </tr>
                    <tr>
                        <td>Monitoring</td>
                        <td>Logging and metrics enabled</td>
                        <td>‚òê</td>
                    </tr>
                    <tr>
                        <td>Networking</td>
                        <td>Load balancer configured</td>
                        <td>‚òê</td>
                    </tr>
                    <tr>
                        <td>Backup</td>
                        <td>Persistent data backed up</td>
                        <td>‚òê</td>
                    </tr>
                </tbody>
            </table>

            <h3>Common Mistakes to Avoid</h3>
            <div class="error-box">
                <p>‚ùå <strong>Don't:</strong></p>
                <ul>
                    <li>Run containers as root user</li>
                    <li>Use <code>latest</code> tag in production</li>
                    <li>Store secrets in images or environment variables</li>
                    <li>Ignore resource limits (causes node crashes)</li>
                    <li>Skip health checks</li>
                    <li>Deploy directly to production without testing</li>
                    <li>Forget to implement logging</li>
                    <li>Over-provision resources (increases costs)</li>
                </ul>
            </div>

            <h3>Optimization Tips</h3>
            <div class="success-box">
                <p>üí° <strong>Performance Optimization:</strong></p>
                <ul>
                    <li>Use multi-stage builds to reduce image size</li>
                    <li>Implement caching strategies for builds</li>
                    <li>Use CDN for static content</li>
                    <li>Enable container image caching</li>
                    <li>Optimize application startup time</li>
                    <li>Use horizontal pod autoscaling</li>
                    <li>Implement proper resource requests/limits</li>
                </ul>
            </div>

            <h3>üîó Key Takeaways</h3>
            <ul>
                <li>Docker provides containerization; orchestration tools manage containers at scale</li>
                <li>Kubernetes is industry-standard, cloud-agnostic orchestration</li>
                <li>AWS ECS simplifies container management without Kubernetes complexity</li>
                <li>AWS EKS provides managed Kubernetes on AWS infrastructure</li>
                <li>Choose based on requirements: ECS for simplicity, EKS for Kubernetes ecosystem, self-managed for full control</li>
                <li>Always implement security, monitoring, and scaling from the start</li>
                <li>Use infrastructure as code (IaC) for reproducible deployments</li>
                <li>Continuous learning is essential - container technology evolves rapidly</li>
            </ul>

            <h3>üìö Additional Resources for Study</h3>
            <ul>
                <li><strong>Docker Documentation:</strong> <a href="https://docs.docker.com/" target="_blank">docs.docker.com</a></li>
                <li><strong>Kubernetes Documentation:</strong> <a href="https://kubernetes.io/docs/" target="_blank">kubernetes.io/docs</a></li>
                <li><strong>AWS ECS Documentation:</strong> <a href="https://docs.aws.amazon.com/ecs/" target="_blank">docs.aws.amazon.com/ecs</a></li>
                <li><strong>AWS EKS Documentation:</strong> <a href="https://docs.aws.amazon.com/eks/" target="_blank">docs.aws.amazon.com/eks</a></li>
                <li><strong>Recommended Video:</strong> Learn with Chirag - Complete CI/CD Project (2 hours)</li>
            </ul>

        </div>

        <div class="tags">
            <span class="tag">Docker</span>
            <span class="tag">Kubernetes</span>
            <span class="tag">AWS ECS</span>
            <span class="tag">AWS EKS</span>
            <span class="tag">Container Orchestration</span>
            <span class="tag">DevOps</span>
        </div>
    </div>

    <script src="../../../js/theme.js"></script>
</body>
</html>