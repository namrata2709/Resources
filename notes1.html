<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker & Kubernetes - Comprehensive Overview (Part 1 of 3)</title>
    <link rel="stylesheet" href="notes-template.css">
</head>
<body>
    <button id="themeToggle" class="theme-toggle">
        <span class="theme-icon"></span>
    </button>

    <div class="note-container">
        <div class="note-header">
            <h1>Docker & Kubernetes Fundamentals - Part 1</h1>
            <p class="note-date">üìÖ December 23, 2025</p>
        </div>

        <div class="note-content">
            <h2>Executive Summary</h2>
            <p>This comprehensive guide covers containerization and orchestration technologies essential for modern cloud infrastructure. You'll learn Docker for creating and managing containers, understand why container orchestration is necessary, explore Kubernetes architecture and components, and discover AWS container services (ECR, ECS, EKS, Fargate). By the end, you'll understand how to deploy, scale, and manage containerized applications in production environments.</p>

            <h2>Table of Contents</h2>
            <ol>
                <li><a href="#introduction">Introduction to Containers</a></li>
                <li><a href="#docker-fundamentals">Docker Fundamentals</a></li>
                <li><a href="#docker-components">Docker Components & Architecture</a></li>
                <li><a href="#docker-images">Docker Images & Registries</a></li>
                <li><a href="#docker-compose">Docker Compose for Multi-Container Apps</a></li>
                <li><a href="#docker-networking">Docker Networking</a></li>
                <li><a href="#docker-volumes">Docker Volumes & Data Persistence</a></li>
                <li><a href="#orchestration-need">Why Container Orchestration?</a></li>
                <li><a href="#kubernetes-intro">Introduction to Kubernetes</a></li>
                <li><a href="#kubernetes-architecture">Kubernetes Architecture</a></li>
                <li><a href="#kubernetes-components">Kubernetes Components Deep Dive</a></li>
                <li><a href="#aws-container-services">AWS Container Services</a></li>
            </ol>

            <h2 id="introduction">1. Introduction to Containers</h2>

            <h3>Real-Life Analogy</h3>
            <div class="info-box">
                <p>üí° <strong>Think of Containers like Shipping Containers:</strong></p>
                <ul>
                    <li><strong>Traditional Deployment (VM)</strong> is like shipping goods in different vehicles - cars, trucks, ships - each requiring different handling</li>
                    <li><strong>Containers</strong> are like standardized shipping containers - same size, same handling, can be moved from ship to truck to train without unpacking</li>
                    <li><strong>Container Contents</strong> are isolated - what's inside one container doesn't affect another</li>
                    <li><strong>Efficiency</strong> - you can stack many containers on one ship (host machine) efficiently</li>
                </ul>
                <p><strong>For example:</strong> Just like a shipping container holds everything needed for transport (goods, packing materials, documentation), a Docker container holds everything needed to run an application (code, runtime, libraries, dependencies).</p>
            </div>

            <h3>What Are Containers?</h3>
            <p>Containers are lightweight, standalone packages that contain everything needed to run an application: application code, runtime environment, system libraries, and dependencies. Unlike virtual machines that require a full operating system, containers share the host OS kernel, making them much more efficient.</p>

            <h3>Why Use Containers?</h3>
            <ul>
                <li><strong>Consistency:</strong> "Works on my machine" problems disappear - if it runs in a container locally, it runs the same way in production</li>
                <li><strong>Efficiency:</strong> No need to pre-allocate full OS or hardware resources - containers use only what they need</li>
                <li><strong>Speed:</strong> Start in seconds (vs minutes for VMs)</li>
                <li><strong>Isolation:</strong> Applications run independently without conflicts</li>
                <li><strong>Portability:</strong> Run anywhere - laptop, data center, cloud</li>
            </ul>

            <h2 id="docker-fundamentals">2. Docker Fundamentals</h2>

            <h3>Real-Life Analogy</h3>
            <div class="info-box">
                <p>üí° <strong>Think of Docker like a Restaurant Kitchen:</strong></p>
                <ul>
                    <li><strong>Recipe (Dockerfile)</strong> - Instructions for making a dish</li>
                    <li><strong>Prepared Dish Template (Docker Image)</strong> - The standard version of the dish that can be replicated</li>
                    <li><strong>Actual Served Dish (Container)</strong> - The running instance that customers consume</li>
                    <li><strong>Kitchen Equipment (Docker Runtime)</strong> - What actually cooks/runs the dish</li>
                </ul>
            </div>

            <h3>What is Docker?</h3>
            <p>Docker is a containerization platform that allows you to build, run, and manage containers. It's the main runtime environment that builds and runs containers. Docker makes it easy to create containers from blueprints (images) and manage their lifecycle.</p>

            <h3>Docker Workflow Overview</h3>
            <ol>
                <li><strong>Write Dockerfile:</strong> Create instructions for your container</li>
                <li><strong>Build Image:</strong> Docker processes the Dockerfile to create a read-only template</li>
                <li><strong>Run Container:</strong> Create running instances from the image</li>
                <li><strong>Store Image:</strong> Push to registry (Docker Hub, ECR) for sharing and deployment</li>
            </ol>

            <h2 id="docker-components">3. Docker Components & Architecture</h2>

            <h3>Docker Installation Components</h3>
            <p>When you install Docker, you get two main components:</p>

            <table>
                <thead>
                    <tr>
                        <th>Component</th>
                        <th>Type</th>
                        <th>Purpose</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Docker CLI</strong></td>
                        <td>User Interface</td>
                        <td>Command-line tool where users type Docker commands</td>
                        <td><code>docker run</code>, <code>docker ps</code>, <code>docker images</code></td>
                    </tr>
                    <tr>
                        <td><strong>Docker Daemon</strong></td>
                        <td>Background Service</td>
                        <td>Service that runs in background and executes Docker commands</td>
                        <td>Manages containers, images, networks, volumes</td>
                    </tr>
                </tbody>
            </table>

            <h3>How Docker Components Communicate</h3>
            <ol>
                <li><strong>User types command:</strong> <code>docker run nginx</code></li>
                <li><strong>Docker CLI receives command:</strong> Validates syntax</li>
                <li><strong>Docker CLI sends to Docker Daemon:</strong> Via REST API</li>
                <li><strong>Docker Daemon executes:</strong> Creates and starts container</li>
                <li><strong>Response returns to user:</strong> Success or error message</li>
            </ol>

            <h3>Docker User and Permissions</h3>

            <div class="highlight-box">
                <p>‚ö†Ô∏è <strong>Important:</strong> By default, only the root user can run Docker commands. Non-root users must be added to the Docker group.</p>
            </div>

            <h4>Why User Permissions Matter</h4>
            <table>
                <thead>
                    <tr>
                        <th>Scenario</th>
                        <th>Without Docker Group</th>
                        <th>With Docker Group</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Running Docker commands</td>
                        <td>Must use <code>sudo</code> every time</td>
                        <td>Can run commands directly</td>
                    </tr>
                    <tr>
                        <td>Security</td>
                        <td>More secure but inconvenient</td>
                        <td>Convenient but grants root-equivalent access</td>
                    </tr>
                    <tr>
                        <td>Automation scripts</td>
                        <td>Difficult to automate</td>
                        <td>Easy to automate</td>
                    </tr>
                </tbody>
            </table>

            <h4>Adding User to Docker Group</h4>

            <h5>Method 1: AWS CLI</h5>
            <pre><code># Add ubuntu user to docker group
sudo usermod -aG docker ubuntu

# Activate the new group (without logging out)
newgrp docker

# Verify group membership
groups ubuntu</code></pre>

            <h5>Method 2: AWS Console (Not Applicable)</h5>
            <p>User management in EC2 instances must be done via CLI/SSH as AWS Console doesn't provide direct Linux user group management.</p>

            <div class="info-box">
                <p>üí° <strong>Tip:</strong> After adding a user to the docker group, they need to log out and log back in, or run <code>newgrp docker</code> for the changes to take effect.</p>
            </div>

            <h3>Scenario 1: Docker Permission Error (Worst-Case)</h3>
            <p><strong>Context:</strong> A DevOps engineer deployed an automation script that runs Docker commands. The script fails in production.</p>
            <p><strong>Action:</strong> Reviewed logs and found: <code>permission denied while trying to connect to the Docker daemon socket</code></p>
            <p><strong>Root Cause:</strong> The user account running the script wasn't added to the docker group</p>
            <p><strong>Resolution:</strong> Added user to docker group: <code>sudo usermod -aG docker jenkins</code> and restarted the service</p>
            <p><strong>Key Lesson:</strong> Always verify user permissions when setting up Docker, especially for service accounts used in automation.</p>

            <h3>Scenario 2: Docker Service Not Running (Worst-Case)</h3>
            <p><strong>Context:</strong> After server restart, developers report they cannot run any Docker commands</p>
            <p><strong>Action:</strong> Attempted to run <code>docker ps</code> and received: <code>Cannot connect to the Docker daemon</code></p>
            <p><strong>Root Cause:</strong> Docker daemon service wasn't set to auto-start on boot</p>
            <p><strong>Resolution:</strong></p>
            <pre><code># Check service status
sudo systemctl status docker

# Start Docker service
sudo systemctl start docker

# Enable auto-start on boot
sudo systemctl enable docker</code></pre>
            <p><strong>Key Lesson:</strong> Always enable Docker service to start automatically on system boot in production environments.</p>

            <h3>Troubleshooting Docker Installation</h3>
            <table>
                <thead>
                    <tr>
                        <th>Problem</th>
                        <th>Possible Cause</th>
                        <th>Solution</th>
                        <th>Prevention</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Permission denied error</td>
                        <td>User not in docker group</td>
                        <td><code>sudo usermod -aG docker $USER</code></td>
                        <td>Add all required users during initial setup</td>
                    </tr>
                    <tr>
                        <td>Cannot connect to daemon</td>
                        <td>Docker service not running</td>
                        <td><code>sudo systemctl start docker</code></td>
                        <td>Enable service: <code>sudo systemctl enable docker</code></td>
                    </tr>
                    <tr>
                        <td>Commands not found</td>
                        <td>Docker not installed properly</td>
                        <td>Reinstall Docker using official installation script</td>
                        <td>Verify installation: <code>docker --version</code></td>
                    </tr>
                    <tr>
                        <td>Service fails to start</td>
                        <td>Port conflict or corrupted installation</td>
                        <td>Check logs: <code>journalctl -u docker</code></td>
                        <td>Use standard ports, regular system updates</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="docker-images">4. Docker Images & Registries</h2>

            <h3>Real-Life Analogy</h3>
            <div class="info-box">
                <p>üí° <strong>Think of Docker Images like Software Installation Files:</strong></p>
                <ul>
                    <li><strong>Image</strong> is like an .exe or .dmg file - contains everything needed to create the running application</li>
                    <li><strong>Container</strong> is like the installed, running application</li>
                    <li><strong>Docker Hub</strong> is like an app store where you download installation files</li>
                    <li><strong>Building Image</strong> is like creating your own custom software installer</li>
                </ul>
            </div>

            <h3>What is a Docker Image?</h3>
            <p>A Docker image is a read-only template that contains:</p>
            <ul>
                <li>Application code</li>
                <li>Runtime environment (Python, Node.js, Java, etc.)</li>
                <li>System libraries</li>
                <li>Dependencies</li>
                <li>Configuration files</li>
                <li>Environment variables</li>
            </ul>

            <p>Images are immutable - once built, they don't change. If you need to modify an application, you build a new image.</p>

            <h3>Dockerfile: Blueprint for Images</h3>
            <p>A Dockerfile is a text file containing instructions to build a Docker image. It's infrastructure as code for containers.</p>

            <h4>Common Dockerfile Instructions</h4>
            <table>
                <thead>
                    <tr>
                        <th>Instruction</th>
                        <th>Purpose</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>FROM</code></td>
                        <td>Specify base image</td>
                        <td><code>FROM python:3.9-slim</code></td>
                    </tr>
                    <tr>
                        <td><code>WORKDIR</code></td>
                        <td>Set working directory</td>
                        <td><code>WORKDIR /app</code></td>
                    </tr>
                    <tr>
                        <td><code>COPY</code></td>
                        <td>Copy files into image</td>
                        <td><code>COPY . .</code></td>
                    </tr>
                    <tr>
                        <td><code>RUN</code></td>
                        <td>Execute commands during build</td>
                        <td><code>RUN pip install -r requirements.txt</code></td>
                    </tr>
                    <tr>
                        <td><code>EXPOSE</code></td>
                        <td>Document port usage</td>
                        <td><code>EXPOSE 8080</code></td>
                    </tr>
                    <tr>
                        <td><code>CMD</code></td>
                        <td>Default command to run</td>
                        <td><code>CMD ["python", "app.py"]</code></td>
                    </tr>
                </tbody>
            </table>

            <h4>Sample Dockerfile for Python Application</h4>
            <pre><code># Use lightweight Python base image
FROM python:3.9-slim

# Set working directory in container
WORKDIR /app

# Copy requirements file
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY app.py .

# Expose port
EXPOSE 5000

# Run application
CMD ["python", "app.py"]</code></pre>

            <h4>Building Docker Image</h4>

            <h5>Method 1: AWS CLI</h5>
            <pre><code># Navigate to directory containing Dockerfile
cd /path/to/your/project

# Build image with tag
docker build -t myapp:v1.0 .

# View built images
docker images

# Run container from image
docker run -d -p 8080:5000 --name myapp-container myapp:v1.0</code></pre>

            <h5>Method 2: AWS Console (Not Applicable)</h5>
            <p>Docker image building must be done via CLI as it requires access to the Docker daemon on the host machine.</p>

            <h3>Scenario Comparison: Docker Image Building</h3>
            <table>
                <thead>
                    <tr>
                        <th>Scenario</th>
                        <th>Type</th>
                        <th>Context</th>
                        <th>Action</th>
                        <th>Outcome</th>
                        <th>Key Lesson</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Quick Development Build</td>
                        <td>Best Case</td>
                        <td>Developer testing new feature locally</td>
                        <td>Created simple Dockerfile, built image, ran container</td>
                        <td>Application ran successfully in 2 minutes</td>
                        <td>Docker enables rapid development and testing</td>
                    </tr>
                    <tr>
                        <td>Large Image Size</td>
                        <td>Worst Case</td>
                        <td>Production image taking 2GB, slow deployments</td>
                        <td>Used full Ubuntu base image with many unnecessary packages</td>
                        <td>Slow builds, expensive storage, slow container startup</td>
                        <td>Always use minimal base images (alpine, slim variants)</td>
                    </tr>
                    <tr>
                        <td>Missing Dependencies</td>
                        <td>Edge Case</td>
                        <td>Container works locally but fails in production</td>
                        <td>Forgot to include system library in Dockerfile</td>
                        <td>Application crashed with "library not found" error</td>
                        <td>Test images in clean environment before production</td>
                    </tr>
                    <tr>
                        <td>E-commerce Deployment</td>
                        <td>Real-World</td>
                        <td>Deploying microservices for shopping website</td>
                        <td>Created separate images for frontend, backend, payment service</td>
                        <td>Scaled each service independently based on load</td>
                        <td>Containers enable microservices architecture</td>
                    </tr>
                </tbody>
            </table>

            <div class="info-box">
                <p>üìÑ <strong>Continued in Part 2...</strong></p>
            </div>